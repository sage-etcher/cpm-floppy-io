*
* https://github.com/sage-etcher/cpm-read-write.git
*
* GitHub:   sage-etcher
* Email:    sage.message@email.com
* Discord:  sage4424
*

*
*  Copyright 2024 Sage I. Hendricks  
*
*  Licensed under the Apache License, Version 2.0 (the "License");  
*  you may not use this file except in compliance with the License.  
*  You may obtain a copy of the License at  
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software  
*  distributed under the License is distributed on an "AS IS" BASIS,  
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
*  See the License for the specific language governing permissions and  
*  limitations under the License.  
*


*CPM STUFF
TPA		EQU	0100H		;CP/M's TRANSIENT PROGRAM AREA
BDOS		EQU	0005H		;SYSCALL CALL ADDR
C$READ		EQU	1		;BDOS CHARACTER INPUT 
C$WRITE		EQU	2		;BDOS CHARACTER OUTPUT
C$WRITESTR	EQU	9		;BDOS STRING OUTPUT
C$READSTR	EQU	10		;BDOS STRING INPUT
DRV$SET		EQU	14		;BDOS DRIVE SELECT
F$OPEN		EQU	15		;BDOS FILE OPEN
F$CLOSE		EQU	16		;BDOS FILE CLOSE
F$READ		EQU	20		;BDOS READ NEXT RECORD (128 BYTES)
F$WRITE		EQU	21		;BDOS WRITE NEXT RECORD "
F$MAKE		EQU	22		;BDOS CREATE FILE
F$DMAOFF	EQU	26		;BDOS SET DMA ADDRESS

SUCCESS		EQU	0		;GENERAL SUCCESS
FAILURE		EQU	0FFH		;GENERAL FAILURE

OK		EQU	0		;FILE IO OKAY
END$OF$FILE	EQU	1		;FILE IO END OF FILE
DIRECTORY$FULL	EQU	1		;FILE IO DIRECTORY FULL
DISK$FULL	EQU	2		;FILE IO DISK FULL
INVALID$FCB	EQU	9		;FILE IO INVALID FCB
MEDIA$CHANGED	EQU	10		;FILE IO FILE CHANGED
HARDWARE$ERROR	EQU	0FFH		;FILE IO HARDWARE ERROR

DRIVE$OFF	EQU	'A'-1		;OFFSET BETWEEN DRIVE LETTER AND ID
DRIVE$DEFAULT	EQU	0		;USE DEFAULT DRIVE
MIN$DRIVE	EQU	'A'		;MINIMUM DRIVE
MAX$DRIVE	EQU	'P'		;MAXIMUM DRIVE

*CHARACTERS
LF	EQU	0AH	;LINE FEED ASCII
CR	EQU	0DH	;CARTIDGE RETURN ASCII
TAB	EQU	09H	;TAB ASCII
TERM	EQU	'$'	;STRING TERMINATOR CHARACTER

*CODE START
	ORG	TPA		;SET ORIGIN POINT
	JMP	MAIN		;SKIP PAST COPYRIGHT DISCLAIMER TO CODE

	DB	' COPYRIGHT (C) 2024 SAGE I. HENDRICKS '

MAIN:
	CALL	PROMPT$ALL	;PROMPT THE USER TO ENTER NEEDED INFORMATION
	CALL	PRINT$FILE	;PRINT THE FILE TO THE CONSOLE

EXIT:	RST	0		;WARMBOOT THE SYSTEM, EXIT THE PROGRAM

PUTCH:	;E=CHARACTER
	MVI	C,C$WRITE	;LOAD BDOS PROC ID
	CALL	BDOS		;PRINT THE CHARACTER IN E REG

GETCH:	;RETURN A=CHARACTER
	MVI	C,C$READ	;LOAD BDOS PROC ID
	CALL	BDOS		;GET 1 CHARACTER FROM THE TERMINAL
	RET

CRLF:
	MVI	E,CR		;LOAD THE CARTRIDGE RETURN CHAR
	CALL	PUTCH		;PRINT THE CHARACTER

	MVI	E,LF		;LOAD THE LINEFEED CHAR
	CALL	PUTCH		;PRINT THE CHARACTER

	RET

PRINT:	;DE=STRING
	MVI	C,C$WRITESTR	;LOAD BDOS PROC ID
	CALL	BDOS		;PRINT THE STRING
	RET

PRINTL:	;DE=STRING
	CALL	PRINT		;PRINT THE STRING
	CALL	CRLF		;PRINT THE NEW LINE
	RET

PRINTN:	;A=LENGTH,  DE=STRING
	CPI	0	;CHECK IF THE INCREMENTOR IS AT 0
	RZ		;IF IT IS, STOP

	PUSH	PSW
	PUSH	D

	MOV	E,M	;LOAD THE CHARACTER
	CALL	PUTCH	;PRINT THE CHARACTER

	POP	D
	POP	PSW

	INX	D	;INCREMENT TO NEXT CHAR
	DCR	A	;DECREMENT THE INCREMENTOR
	JMP	PRINTN	;LOOP
	

INPUT:	;C=LENGTH, RETURN BUFFER
	LXI	H,BUFF$SIZE	;GET THE SIZE VARIABLE
	MOV	M,C		;STORE THE MAXLENGTH

	MVI	A,0		;CONTENT CHAR COUNT = 0
	STA	BUFF$COUNT	;RESET THE COUNT
	
	LXI	D,BUFFER	;STORE THE STRING BUFFER IN DE
	MVI	C,C$READSTR	;USE THE BUFFERED CONSOLE INPUT PROC
	CALL	BDOS		;GET THE STRING

	RET

SELECT$DISK:	;E=DRIVE ID
	MVI	C,DRV$SET	;LOAD BDOS PROC ID
	CALL	BDOS		;SELECT THE DRIVE

	CPI	SUCCESS		;CHECK IF THE OPERATION WAS SUCCESSFUL
	RZ			;RETURN IF SO

	JMP	DRIVE$ERROR	;PRINT AN ERROR AND ABORT

OPEN$FILE:	;DE=FCB
	MVI	C,F$OPEN	;LOAD BDOS PROC ID
	CALL	BDOS		;OPEN THE FILE

	CPI	FAILURE		;CHECK IF THE PROCEDURE FAILED
	JZ	FILE$ERROR	;IF IT DID, THROW AN ERROR AND ABORT
				;OTHERWISE, CONTINUE SETUP
				
	MVI	A,0		;DEFAULT VALUE
	STA	FCB$EX		;SET ONCE
	STA	FCB$RC		;SET ONCE
	STA	FCB$S2		;SET ONCE
	STA	FCB$CR		;SET ONCE

	RET

CLOSE$FILE:	;DE=FCB
	MVI	C,F$CLOSE	;LOAD BDOS PROC ID
	CALL	BDOS		;CLOSE THE FILE

	CPI	FAILURE		;CHECK IF THE PROCEDURE FAILED
	JZ	FILE$ERROR	;IF IT DID, THROW AN ERROR AND ABORT

	RET

MEMCPY:	;A=SIZE,  DE=DEST,  HL=SRC
	CPI	0		;CHECK IF THE ITERATOR HAS REACHED 0
	RZ			;RETURN IF SO

	MOV	B,M		;GET BYTE FROM SOURCE LOCATION
	XCHG			;MOVE DEST ADDR INTO HL
	MOV	M,B		;STORE THE BYTE INTO DEST ADDR
	XCHG			;RESTORE THE SOURCE ADDR INTO HL

	INX	D		;INCREMENT TO NEXT ADDR
	INX	H		;INCREMENT TO NEXT ADDR
	DCR	A		;DECREMENT ITERATOR

	JMP	MEMCPY		;LOOP BACK UNTIL A == 0

MEMSET:	;A=SIZE,  B=VALUE,  HL=ADDR
	CPI	0		;CHECK IF ITERATOR HAS REACHED 0
	RZ			;RETURN IF SO

	MOV	M,B		;WRITE VALUE TO ADDR

	INX	H		;MOVE TO NEXT MEM LOCATION
	DCR	A		;DECREMENT ITERATOR

	JMP	MEMSET		;LOOP BACK UNTIL A == 0

PROMPT$FILENAME:
	LXI	NAME$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,FILENAME$SIZE	;SPECIFY THE # OF BYTES
	MVI	B,' '		;SET VALUE TO SPACE
	LXI	H,BUFF$MEM	;WRITE TO INPUT BUFFER
	CALL	MEMSET		;WRITE SPACES TO THE MEMORY BUFER

	MVI	C,FILENAME$SIZE	;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT

	MVI	A,FILENAME$SIZE	;# OF BYTES TO COPY
	LXI	D,FCB$NAME	;DEST STRING
	LXI	H,BUFF$MEM	;SOURCE STRING
	CALL	MEMCPY		;COPY NAME TO FILENAME VARIABLE
	
	RET

PROMPT$EXTENSION:
	LXI	EXT$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,EXTENSION$SIZE;SPECIFY THE # OF BYTES
	MVI	B,' '		;SET VALUE TO SPACE
	LXI	H,BUFF$MEM	;WRITE TO INPUT BUFFER
	CALL	MEMSET		;WRITE SPACES TO THE MEMORY BUFER

	MVI	C,EXTENSION$SIZE;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT

	MVI	A,EXTENSION$SIZE;# OF BYTES TO COPY
	LXI	D,FCB$EXT	;DEST STRING
	LXI	H,BUFF$MEM	;SOURCE STRING
	CALL	MEMCPY		;COPY NAME TO FILENAME VARIABLE
	
	RET

PROMPT$DRIVE:
	LXI	DRIVE$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,0		;SET DEFAULT VALUE TO 0
	STA	BUFF$MEM	;WRITE THE DEFAULT VALUE TO FIRST CELL OF MEM

	MVI	C,DRIVE$SIZE	;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT

	MOV	H,DRIVE$MEM	;GRAB THE ADDR OF THE INPUT CHAR

	MOV	B,M		;LOAD DRIVE LETTER INTO B
	MVI	A,MIN$DRIVE-1	;LOAD THE MIN DRIVE LETTER INTO A
	CMP	B		;NO CARRY, IF INPUT < MIN
	JNC	PROPMT$DRIVE	;RE-PROMPT LOOP

	MOV	A,M		;LOAD DRIVE LETTER INTO A
	CPI	MAX$DRIVE+1	;NO CARRY, IF INPUT > MAX
	JNC	PROPMT$DRIVE	;RE-PROMPT LOOP

	SBI	DRIVE$OFF	;CONVERT DRIVE LETTER TO DRIVE ID
	STA	FCB$DRIVE	;STORE THE DRIVE ID INTO FCB

	RET

PROMPT$ALL:
	CALL	PROMPT$FILENAME	;GET THE FILENAME
	CALL	PROMPT$EXTENSION;GET THE FILE EXTENSION
	CALL	PROMPT$DRIVE	;GET THE DRIVE THAT THE FILE IS ON

	RET

PREPARE$OPEN:
	LXI	H,FCB$DRIVE	;LOAD VARIABLE ADDR
	MOV	E,M		;GET VARIABLE VALUE
	CALL	SELECT$DRIVE	;SELECT THE CORRECT DRIVE

	LXI	D,FCB		;USE THE FCB ADDRESS
	CALL	OPEN$FILE	;TRY TO OPEN THE FILE

	RET

PREPARE$EXIT:
	LXI	D,FCB		;USE THE FCB ADDRESS
	CALL	CLOSE$FILE	;TRY TO CLOSE THE FILE 

	RET

READ$RECORD:
	RET

PRINT$FILE:
	CALL	PREPARE$OPEN	;OPEN THE FILE AND DO NECESARY SETUP

	CALL	SET$DMA
	CALL	READ$RECORD	
	
	MVI	A,RECORD$SIZE
	LXI	D,RECORD$BUFF
	CALL	PRINTN

	CALL	PREPARE$CLOSE	;CLOSE THE FILE DOING NECESARY SETUP
	RET

DISPLAY$FILE:
	RET


*DATA START
DRIVE$SIZE	EQU	1		;DRIVE IS AT MAX 1 CHARS
FILENAME$SIZE	EQU	8		;FILENAME IS AT MAX 8 CHARS
EXTENSION$SIZE	EQU	3		;EXTENSION IS AT MAX 3 CHARS

FCB:
FCB$DRIVE:	DB	0		;DRIVE ID
FCB$NAME:	DS	FILENAME$SIZE	;FILENAME
FCB$EXT:	DS	EXTENSION$SIZE	;FILE EXTENSION
FCB$EX:		DB	0		;SET TO 0 AFTER OPENING
FCB$S1:		DS	1		;RESERVED
FCB$S2:		DS	1		;RESERVED
FCB$RC:		DB	0		;SET TO 0 AFTER OPENING
FCB$AL:		DB	0		;TBH NOT A CLUE, GOOD LUCK
FCB$CR:		DB	0		;CURRENT RECORD, SET 0 AFTER OPEN
FCB$RARN:	DW	0000H		;RANDOM ACCESS RECORD NUMBER


RECORD$SIZE	EQU	128		;SIZE OF 1 RECORD
RECORD$BUFF:	DS	RECORD$SIZE	;STORAGE SPACE FOR 1 BLOCK

BUFF$ALLOC	EQU	255		;TRUE ALLOCATED SIZE FOR THE STRING
BUFFER:
BUFF$SIZE:	DB	BUFF$ALLOC	;ALLOC SIZE BUFF$ALLOC
BUFF$COUNT:	DB	0		;REAL LENGTH (0)
BUFF$MEM:	DS	BUFF$ALLOC	;ALLOCATED AREA


	END
