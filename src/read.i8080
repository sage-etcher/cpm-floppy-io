*
* https://github.com/sage-etcher/cpm-read-write.git
*
* GitHub:   sage-etcher
* Email:    sage.message@email.com
* Discord:  sage4424
*

*
*  Copyright 2024 Sage I. Hendricks  
*
*  Licensed under the Apache License, Version 2.0 (the "License");  
*  you may not use this file except in compliance with the License.  
*  You may obtain a copy of the License at  
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software  
*  distributed under the License is distributed on an "AS IS" BASIS,  
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
*  See the License for the specific language governing permissions and  
*  limitations under the License.  
*


*CPM STUFF
TPA		EQU	0100H		;CP/M's TRANSIENT PROGRAM AREA
BDOS		EQU	0005H		;SYSCALL CALL ADDR
C$READ		EQU	1		;BDOS CHARACTER INPUT 
C$WRITE		EQU	2		;BDOS CHARACTER OUTPUT
C$WRITESTR	EQU	9		;BDOS STRING OUTPUT
C$READSTR	EQU	10		;BDOS STRING INPUT
DRV$SET		EQU	14		;BDOS DRIVE SELECT
F$OPEN		EQU	15		;BDOS FILE OPEN
F$CLOSE		EQU	16		;BDOS FILE CLOSE
F$READ		EQU	20		;BDOS READ NEXT RECORD (128 BYTES)
F$WRITE		EQU	21		;BDOS WRITE NEXT RECORD "
F$MAKE		EQU	22		;BDOS CREATE FILE
F$DMAOFF	EQU	26		;BDOS SET DMA ADDRESS

SUCCESS		EQU	0		;GENERAL SUCCESS
FAILURE		EQU	0FFH		;GENERAL FAILURE

OK		EQU	0		;FILE IO OKAY
END$OF$FILE	EQU	1		;FILE IO END OF FILE
DIRECTORY$FULL	EQU	1		;FILE IO DIRECTORY FULL
DISK$FULL	EQU	2		;FILE IO DISK FULL
INVALID$FCB	EQU	9		;FILE IO INVALID FCB
MEDIA$CHANGED	EQU	10		;FILE IO FILE CHANGED
HARDWARE$FAIL	EQU	0FFH		;FILE IO HARDWARE ERROR

DRIVE$OFF	EQU	'A'-2		;OFFSET BETWEEN DRIVE LETTER AND ID
DRIVE$DEFAULT	EQU	0		;USE DEFAULT DRIVE
MIN$DRIVE	EQU	'A'		;MINIMUM DRIVE
MAX$DRIVE	EQU	'P'		;MAXIMUM DRIVE

*CHARACTERS
LF	EQU	0AH	;LINE FEED ASCII
CR	EQU	0DH	;CARTIDGE RETURN ASCII
TAB	EQU	09H	;TAB ASCII
TERM	EQU	'$'	;STRING TERMINATOR CHARACTER

*CODE START
	ORG	TPA		;SET ORIGIN POINT
	JMP	MAIN		;SKIP PAST COPYRIGHT DISCLAIMER TO CODE

	DB	' COPYRIGHT (C) 2024 SAGE I. HENDRICKS '

MAIN:
	CALL	PROMPT$ALL	;PROMPT THE USER TO ENTER NEEDED INFORMATION
	CALL	PRINT$FILE	;PRINT THE FILE TO THE CONSOLE

EXIT:	RST	0		;WARMBOOT THE SYSTEM, EXIT THE PROGRAM

PUTCH:	;E=CHARACTER
	MVI	C,C$WRITE	;LOAD BDOS PROC ID
	CALL	BDOS		;PRINT THE CHARACTER IN E REG
	RET

GETCH:	;RETURN A=CHARACTER
	MVI	C,C$READ	;LOAD BDOS PROC ID
	CALL	BDOS		;GET 1 CHARACTER FROM THE TERMINAL
	RET

CRLF:
	MVI	E,CR		;LOAD THE CARTRIDGE RETURN CHAR
	CALL	PUTCH		;PRINT THE CHARACTER

	MVI	E,LF		;LOAD THE LINEFEED CHAR
	CALL	PUTCH		;PRINT THE CHARACTER

	RET

TO$UPPER:	;E=CHARACTER,  RETURN A=CHARACTER
	MVI	A,'a'-1		;LOWER BOUND (INCLUSIVE)
	CMP	E		;IS THE CHAR >= 'a'
	JNC	NOT$LOWERCASE	;IF IT ISNT, RETURN

	MOV	A,E		;MOVE THE CHACTER INTO A REG
	MVI	B,'z'+1		;UPPER BOUND (INCLUSIVE)
	CMP	B		;IS THE CHAR <= 'z'
	JNC	NOT$LOWERCASE	;IF IT ISNT, RETURN

	SBI	'a'-'A'-1	;CONVERT THE CHAR TO UPPER

	RET
NOT$LOWERCASE:
	MOV	A,E		;MOVE THE CHARACTER INTO THE RET REG

	RET

STR$TO$UPPER:	;HL=STRING ADDR,  A=CHAR COUNT
	CPI	0		;CHECK THE ITERATOR
	RZ			;RETURN WHEN IT REACHES 0

	PUSH	PSW		;STORE THE ITERATOR
	PUSH	H		;STORE THE CHAR POINTER
	MOV	E,M		;GRAB THE CHARACTER
	CALL	TO$UPPER	;CONVER THE CHARACTER TO UPPER CASE
	
	POP	H		;RESTORE THE CHARACTER POINTER
	MOV	M,A		;STORE THE CHARACTER BACK INTO MEMORY

	POP	PSW		;RESTORE THE ITERATOR

	INX	H		;MOVE TO NEXT CHARACTER
	DCR	A		;DECREMENT ITERATOR
	JMP	STR$TO$UPPER

PRINT:	;DE=STRING
	MVI	C,C$WRITESTR	;LOAD BDOS PROC ID
	CALL	BDOS		;PRINT THE STRING
	RET

PRINTL:	;DE=STRING
	CALL	PRINT		;PRINT THE STRING
	CALL	CRLF		;PRINT THE NEW LINE
	RET

PRINTN:	;A=LENGTH,  HL=STRING
	CPI	0	;CHECK IF THE INCREMENTOR IS AT 0
	RZ		;IF IT IS, STOP

	PUSH	PSW
	PUSH	H

	MOV	E,M	;LOAD THE CHARACTER
	CALL	PUTCH	;PRINT THE CHARACTER

	POP	H
	POP	PSW

	INX	H	;INCREMENT TO NEXT CHAR
	DCR	A	;DECREMENT THE INCREMENTOR
	JMP	PRINTN	;LOOP
	

INPUT:	;C=LENGTH, RETURN BUFFER
	LXI	H,BUFF$SIZE	;GET THE SIZE VARIABLE
	MOV	M,C		;STORE THE MAXLENGTH

	MVI	A,0		;CONTENT CHAR COUNT = 0
	STA	BUFF$COUNT	;RESET THE COUNT
	
	LXI	D,BUFFER	;STORE THE STRING BUFFER IN DE
	MVI	C,C$READSTR	;USE THE BUFFERED CONSOLE INPUT PROC
	CALL	BDOS		;GET THE STRING

	CALL	CRLF		;PRINT A NEW LINE

	RET

SELECT$DISK:	;E=DRIVE ID
	;DCR	E		;CONVERT DRIVE ID TO WORK
	MVI	C,DRV$SET	;LOAD BDOS PROC ID
	CALL	BDOS		;SELECT THE DRIVE

	CPI	SUCCESS		;CHECK IF THE OPERATION WAS SUCCESSFUL
	RZ			;RETURN IF SO

	JMP	DRIVE$ERROR	;PRINT AN ERROR AND ABORT

OPEN$FILE:	;DE=FCB
	MVI	C,F$OPEN	;LOAD BDOS PROC ID
	CALL	BDOS		;OPEN THE FILE

	CPI	FAILURE		;CHECK IF THE PROCEDURE FAILED
	JZ	FILE$ERROR	;IF IT DID, THROW AN ERROR AND ABORT
				;OTHERWISE, CONTINUE SETUP
				
	MVI	A,0		;DEFAULT VALUE
	STA	FCB$EX		;SET ONCE
	STA	FCB$S1		;SET ONCE
	STA	FCB$S2		;SET ONCE
	STA	FCB$RC		;SET ONCE
	STA	FCB$CR		;SET ONCE

	RET

CLOSE$FILE:	;DE=FCB
	MVI	C,F$CLOSE	;LOAD BDOS PROC ID
	CALL	BDOS		;CLOSE THE FILE

	CPI	FAILURE		;CHECK IF THE PROCEDURE FAILED
	JZ	FILE$ERROR	;IF IT DID, THROW AN ERROR AND ABORT

	RET

MEMCPY:	;A=SIZE,  DE=DEST,  HL=SRC
	CPI	0		;CHECK IF THE ITERATOR HAS REACHED 0
	RZ			;RETURN IF SO

	MOV	B,M		;GET BYTE FROM SOURCE LOCATION
	XCHG			;MOVE DEST ADDR INTO HL
	MOV	M,B		;STORE THE BYTE INTO DEST ADDR
	XCHG			;RESTORE THE SOURCE ADDR INTO HL

	INX	D		;INCREMENT TO NEXT ADDR
	INX	H		;INCREMENT TO NEXT ADDR
	DCR	A		;DECREMENT ITERATOR

	JMP	MEMCPY		;LOOP BACK UNTIL A == 0

MEMSET:	;A=SIZE,  B=VALUE,  HL=ADDR
	CPI	0		;CHECK IF ITERATOR HAS REACHED 0
	RZ			;RETURN IF SO

	MOV	M,B		;WRITE VALUE TO ADDR

	INX	H		;MOVE TO NEXT MEM LOCATION
	DCR	A		;DECREMENT ITERATOR

	JMP	MEMSET		;LOOP BACK UNTIL A == 0

PROMPT$FILENAME:
	LXI	D,FILENAME$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,FILENAME$SIZE	;SPECIFY THE # OF BYTES
	MVI	B,' '		;SET VALUE TO SPACE
	;MVI	B,0		;SET VALUE TO NULL
	LXI	H,BUFF$MEM	;WRITE TO INPUT BUFFER
	CALL	MEMSET		;WRITE SPACES TO THE MEMORY BUFER

	MVI	C,FILENAME$SIZE	;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT

	LXI	H,BUFF$MEM	;BASE OF STRING
	MVI	A,FILENAME$SIZE	;LENGTH OF STRING
	CALL	STR$TO$UPPER	;CONVERT THE STRING TO UPPERCASE

	MVI	A,FILENAME$SIZE	;# OF BYTES TO COPY
	LXI	D,FCB$NAME	;DEST STRING
	LXI	H,BUFF$MEM	;SOURCE STRING
	CALL	MEMCPY		;COPY NAME TO FILENAME VARIABLE
	
	RET

PROMPT$EXTENSION:
	LXI	D,EXT$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,EXTENSION$SIZE;SPECIFY THE # OF BYTES
	;MVI	B,0		;SET VALUE TO NULL
	MVI	B,' '		;SET VALUE TO SPACE
	LXI	H,BUFF$MEM	;WRITE TO INPUT BUFFER
	CALL	MEMSET		;WRITE SPACES TO THE MEMORY BUFER

	MVI	C,EXTENSION$SIZE;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT
	
	LXI	H,BUFF$MEM	;BASE OF STRING
	MVI	A,EXTENSION$SIZE;LENGTH OF STRING
	CALL	STR$TO$UPPER	;CONVERT THE STRING TO UPPERCASE

	MVI	A,EXTENSION$SIZE;# OF BYTES TO COPY
	LXI	D,FCB$EXT	;DEST STRING
	LXI	H,BUFF$MEM	;SOURCE STRING
	CALL	MEMCPY		;COPY NAME TO FILENAME VARIABLE
	
	RET

PROMPT$DRIVE:
	LXI	D,DRIVE$PROMPT	;LOAD THE FILENAME PROMPT
	CALL	PRINT		;PRINT THE STRING

	MVI	A,0		;SET DEFAULT VALUE TO 0
	STA	BUFF$MEM	;WRITE THE DEFAULT VALUE TO FIRST CELL OF MEM

	MVI	C,DRIVE$SIZE	;SPECIFY MAX SIZE FOR FILENAME
	CALL	INPUT		;GET USER INPUT

	LXI	H,BUFF$MEM	;GRAB THE ADDR OF THE INPUT CHAR
	MOV	E,M		;LOAD THE DRVIE LETTER INTO E
	CALL	TO$UPPER	;MAKE SURE THE CHARACTER IS UPPER
	LXI	H,BUFF$MEM	;GRAB THE ADDR OF THE INPUT CHAR
	MOV	M,A		;STORE THE VALUE BACK INTO THE BUFFER

	MOV	B,M		;LOAD DRIVE LETTER INTO B
	MVI	A,MIN$DRIVE-1	;LOAD THE MIN DRIVE LETTER INTO A
	CMP	B		;NO CARRY, IF INPUT < MIN
	JNC	PROMPT$DRIVE	;RE-PROMPT LOOP

	MOV	A,M		;LOAD DRIVE LETTER INTO A
	CPI	MAX$DRIVE+1	;NO CARRY, IF INPUT > MAX
	JNC	PROMPT$DRIVE	;RE-PROMPT LOOP

	SBI	DRIVE$OFF	;CONVERT DRIVE LETTER TO DRIVE ID
	STA	FCB$DRIVE	;STORE THE DRIVE ID INTO FCB

	RET

PROMPT$ALL:
	CALL	PROMPT$FILENAME	;GET THE FILENAME
	CALL	PROMPT$EXTENSION;GET THE FILE EXTENSION
	CALL	PROMPT$DRIVE	;GET THE DRIVE THAT THE FILE IS ON

	RET

PREPARE$OPEN:	;HL=FCB ADDR
	PUSH	H		;STORE THE FCB
	MOV	E,M		;GET VARIABLE VALUE
	DCR	E		;DRIVE SELECT REQUIRES DRIVE TO BE 1 LESS
	CALL	SELECT$DISK	;SELECT THE CORRECT DRIVE

	POP	H		;RESTORE THE FCB ADDR
	XCHG			;MOVE THE ADDR INTO DE
	CALL	OPEN$FILE	;TRY TO OPEN THE FILE

	RET

PREPARE$EXIT:
	LXI	D,FCB		;USE THE FCB ADDRESS
	CALL	CLOSE$FILE	;TRY TO CLOSE THE FILE 

	RET

READ$RECORD:	;DE=DMA ADDR,  HL=FCB ADDR
	PUSH	H		;STORE FCB TEMPORARILY
				;DE=DMA ADDR FROM PARAM
	MVI	C,F$DMAOFF	;BDOS PROC ID
	CALL	BDOS		;SET THE DMA ADDRESS
	POP	H		;RESTORE FCB ADDR

	XCHG			;MOVE FCB ADDR TO DE
	MVI	C,F$READ	;BDOS PROC ID
	CALL	BDOS		;READ A RECORD INTO DMA

	CPI	INVALID$FCB	;CHECK FOR FCB ERROR
	JZ	FILE$ERROR	;PRINT ERROR ACCORDINGLY

	CPI	HARDWARE$FAIL	;CHECK FOR HARDWARE FAILURE
	JZ	HARDWARE$ERROR	;PRINT ERROR ACCORDINGLY

	RET

PRINT$FILE:
	LXI	H,FCB		;LOAD THE FCB ADDR FOR PROC
	CALL	PREPARE$OPEN	;OPEN THE FILE AND DO NECESARY SETUP

PRINT$RECORD:
	LXI	D,RECORD$BUFF	;LOAD THE DMA ADDR FOR PROC
	LXI	H,FCB		;LOAD THE FCB ADDR FOR PROC
	CALL	READ$RECORD	;READ RECORD (128 BYTES) INTO DMA
	PUSH	PSW		;SAVE THE RETURN TEMPORARILY

	MVI	A,RECORD$SIZE	;SPECIFY 128 BYTES TO PRINT
	LXI	H,RECORD$BUFF	;SPECIFY THE DATA TO PRINT
	CALL	PRINTN		;PRINT THE LOADED BUFFER

	POP	PSW		;RESTORE THE READ RETURN
	CPI	END$OF$FILE	;CHECK IF WE ARE AT END OF THE FILE
	JNZ	PRINT$RECORD	;IF WE ARENT AT THE END OF THE FILE, LOOP

	CALL	PREPARE$EXIT	;CLOSE THE FILE DOING NECESARY SETUP
	RET

HARDWARE$ERROR:
	LXI	D,HARDWARE$ERR$MSG	;LOAD THE HARDWARE ERROR STRING
	CALL	PRINTL			;PRINT THE STRING
	JMP	EXIT			;ABORT THE PROGRAM
FILE$ERROR:
	LXI	D,FILE$ERR$MSG		;LOAD THE HARDWARE ERROR STRING
	CALL	PRINTL			;PRINT THE STRING
	JMP	EXIT			;ABORT THE PROGRAM
DRIVE$ERROR:
	LXI	D,DRIVE$ERR$MSG		;LOAD THE HARDWARE ERROR STRING
	CALL	PRINTL			;PRINT THE STRING
	JMP	EXIT			;ABORT THE PROGRAM

*DATA START
HARDWARE$ERR$MSG:	DB	'HARDWARE ERROR',TERM
FILE$ERR$MSG:		DB	'FILE ERROR',TERM
DRIVE$ERR$MSG:		DB	'DRIVE ERROR',TERM

FILENAME$PROMPT:	DB	'FILENAME TO READ FROM: ',TERM
EXT$PROMPT:		DB	'FILE EXTENSION: ',TERM
DRIVE$PROMPT:		DB	'DRIVE LETTER (A-P): ',TERM

DRIVE$SIZE	EQU	1		;DRIVE IS AT MAX 1 CHARS
FILENAME$SIZE	EQU	8		;FILENAME IS AT MAX 8 CHARS
EXTENSION$SIZE	EQU	3		;EXTENSION IS AT MAX 3 CHARS

FCB:
FCB$DRIVE:	DS	DRIVE$SIZE
FCB$NAME:	DS	FILENAME$SIZE
FCB$EXT:	DS	EXTENSION$SIZE
FCB$EX:		DS	1
FCB$S1:		DS	1
FCB$S2:		DS	1
FCB$RC:		DS	1
FCB$AL:		DS	16
FCB$CR:		DS	1
FCB$RN:		DS	3

RECORD$SIZE	EQU	128		;SIZE OF 1 RECORD
RECORD$BUFF:	DS	RECORD$SIZE	;STORAGE SPACE FOR 1 BLOCK

BUFF$ALLOC	EQU	255		;TRUE ALLOCATED SIZE FOR THE STRING
BUFFER:
BUFF$SIZE:	DB	BUFF$ALLOC	;ALLOC SIZE BUFF$ALLOC
BUFF$COUNT:	DB	0		;REAL LENGTH (0)
BUFF$MEM:	DS	BUFF$ALLOC	;ALLOCATED AREA


	END
